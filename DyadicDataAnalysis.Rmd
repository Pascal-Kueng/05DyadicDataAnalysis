---
title: "Dyadic Multilevel Modelling"
subtitle: "Distinguishable and Exchangeable Dyads"
author: "Pascal Küng"
date: "last-modified"
format:
  revealjs:
    embed-resources: true
    theme: default
    slide-number: "c/t"
    progress: true
    hash: true
    preview-links: auto
    auto-animate: true
    code-line-numbers: true
    incremental: false
    code-overflow: wrap
    code-copy: true
    code-tools: false
    code-block-height: 650px
    toc: false
    df-print: default
    transition: slide
    transition-speed: fast
    link-external-newwindow: true
    footer: "<span>Dyadic Mulitlevel Modelling • brms/cmdstanr • Pascal Küng</span>"
    css: /Embed/styles.css
bibliography: /Embed/Temp.bib
csl: /Embed/apa.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
gc()
library(glue)
```

## Overview

* Distinguishable Dyads
  * Cross-Sectional APIM
  * Longitudinal APIM
  
* Exchangeable Dyads
  * Cross-Sectional APIM
  * Cross-Secional DIM
  * Equivalence between APIM and DIM
  * Longitudinal DIM
  * Longitudinal APIM
  
## Loading Libraries and setting cmdstan Backend

```{r, results='hide', message=FALSE, warning=FALSE}
library(tidyverse)
library(brms)
library(bmlm)
library(easystats)
library(DiagrammeR)
library(glue)
library(DHARMa)
source(file.path('00_R_Functions', 'ReportModels.R'))
source(file.path('00_R_Functions', 'PrettyTables.R'))
source(file.path('00_R_Functions', 'PrepareData.R'))

set.seed(123)

options(
  brms.backend = 'cmdstan',
  brms.file_refit = 'on_change'
)
```


# Distinguishable Dyads

## Distinguishable Dyads - Cross-Sectional APIM 

## Distinguishable Dyads - Data: Simulated Dyads

```{r}
df <- readRDS('Embed/simulatedCrossSectionalDyadicData.rds')
print_df(head(df))
```


```{r results='hide', echo=FALSE, message=FALSE}
# subseting distinguishable dyads
df_filt <- df %>%
  reshape_dyadic_data(
    person_id = 'userID',
    dyad_id = 'coupleID',
    vars_to_reshape = c('communication', 'gender')
  )  

df <- df[df_filt$gender_actor != df_filt$gender_partner ,]

```

## Distinguishable Dyads - Cross-Sectional APIM

![Distinguishable APIM](APIM_dist.png)



## Distinguishable Dyads - Preparing Data

```{r results='hide', message=FALSE, warning=FALSE}
df_apim <- df %>%
  # Reshaping to Actor-Partner format (4-field)
  reshape_dyadic_data(
    person_id = 'userID',
    dyad_id = 'coupleID',
    vars_to_reshape = 'communication'
  )  %>%
  mutate(
    # Optional: grand-mean centering
    communication_actor_gmc = communication_actor - mean(communication_actor),
    communication_partner_gmc = communication_partner - mean(communication_partner),
    
    # Create Dummy-Variables for male and female
    is_male = ifelse(gender == 1, 1, 0),
    is_female = ifelse(gender == 2, 1, 0),
  ) 

print_df(head(df_apim))

```


```{r echo = FALSE, results='hide', message = FALSE, warning= FALSE, error=FALSE}
# Selecting only distinguishable Dyads

df_apim <- relocate(df_apim, 'is_male', 'is_female', .after = 'gender')

```

---

```{r, echo=FALSE}

print_df(head(df_apim))

```


## Distinguishable Dyads - Fitting the Model in BRMS


```{r }
#| code-line-numbers: "1-13|15-26|28-33|35-46"

formula <- bf(
  satisfaction ~ 
    
    # Remove global intercept, introduce male and female intercepts.
    0 + is_male + is_female +
    
    # Actor effect for male and female
    communication_actor_gmc:is_male + 
    communication_actor_gmc:is_female + 
    
    # Partner effect for male and female
    communication_partner_gmc:is_male + 
    communication_partner_gmc:is_female +
    
    # Option 1: Random intercept for male and female (correlated), not identifiable in the cross-sectional case:
    # (0 + is_male + is_female | coupleID)
    
    # Option 2: Too restrictive, basically modelling Exchangeable dyads with perfect correlation
    # (1 | coupleID) 
    
    # Solution: use compound symmetry of the residuals
    cosy(gr = coupleID),
  
  # Two distinct residual variances for males vs females:
  sigma = ~ 0 + is_male + is_female
)

priors <- c(
  # prior(normal(2, 3), class = "Intercept"),
  prior(normal(0, 5), class = "b"),
  prior(student_t(3, 0, 1.5), class = "b", dpar = "sigma"),
  prior(beta(1, 3), class = "cosy")
)

model_dist_apim <- brm(
  formula = formula, 
  data = df_apim,
  family = gaussian(link = identity),
  prior = priors,
  chains = 4,
  cores = 4,
  iter = 2000,
  warmup = 1000, 
  seed = 123,
  file = file.path('brms_cache', 'example1_dist_apim') # Cache the model
)


```

## Distinguishable Dyads - Check Model Convergence and Fit

```{r cache = TRUE, message=TRUE}
rstan::check_hmc_diagnostics(model_dist_apim$fit)
loo::pareto_k_table(loo(model_dist_apim))
```

--- 

```{r eval=FALSE}
plot(model_dist_apim, ask = FALSE)
```

```{r echo=FALSE}
p1 <- plot(model_dist_apim, ask=FALSE, nvariables = 3, plot = FALSE)
p1[[2]]
```
--- 

```{r cache = TRUE}
pp_check(model_dist_apim, 'dens_overlay_grouped', group = 'is_male')
```

---

```{r cache = TRUE}
pp_check(model_dist_apim, 'ecdf_overlay_grouped', group = 'is_male')
```

---

```{r cache = TRUE}
pp_check(model_dist_apim, type = "loo_pit_overlay")
```

---

```{r cache = TRUE}
DHARMa.check_brms(model_dist_apim)
```

---

```{r echo = FALSE}

summary_apim <- summarize_brms(
    model_dist_apim, 
    stats_to_report = c('CI', 'Rhat', 'ESS')
    )

print_df(
  summary_apim, 
  rows_to_pack = list(
    'Fixed Effects' = c(1,6),
    'Residual Structure' = c(7,9)
    )
  )

```

## Distinguishable Dyads - (Intensive) Longitudinal APIM

## Distinguishable Dyads - L-APIM - Data: Time and Ties

```{r echo = FALSE, results='hide', warning=FALSE, message=FALSE}
df_long <- readRDS('Embed/df_long_pilot.rds')

df_long <- df_long %>% 
  mutate(
    provided_support = (ss_emo_comf + ss_emo_pleasure + ss_emo_reass) / 3,
    daily_closeness = ss_closeness,
    diaryday = day, 
    is_male = ifelse(gender == 1, 1, 0), 
    is_female = ifelse(gender == 2, 1, 0)
  ) %>%
  select(
    c('userID', 'coupleID', 'diaryday', 'gender', 'is_male', 'is_female', 'daily_closeness', 
      'provided_support')
  )
```


```{r echo = FALSE, results='hide', warning=FALSE, message=FALSE}
df_long_apim <- reshape_dyadic_data(
  data = df_long,
  person_id = 'userID',
  dyad_id = 'coupleID',
  time = 'diaryday',
  vars_to_reshape = c('provided_support', 'gender')
) 

df_long_apim <- df_long_apim[df_long_apim$gender_actor != df_long_apim$gender_partner, ]
df_long_apim$gender_actor <- NULL
df_long_apim$gender_partner <- NULL

print_couple_preview <- function(df, couple_id,
                                 days = 0:2) {
  # Filter/sort/select with original types
  dfc0 <- df %>%
    dplyr::filter(coupleID == couple_id) %>%
    dplyr::arrange(userID, diaryday)

  # Identify partners
  partners <- dfc0 %>%
    dplyr::distinct(userID) %>%
    dplyr::arrange(userID) %>%
    dplyr::pull(userID)

  if (length(partners) < 2)
    stop("This couple doesn't have two partners in the data.")

  # Slice by partner & day BEFORE coercion
  p1 <- dfc0 %>% dplyr::filter(userID == partners[1], diaryday %in% days)
  p2 <- dfc0 %>% dplyr::filter(userID == partners[2], diaryday %in% days)

  # Coerce everything to character explicitly (belt-and-suspenders on coupleID)
  to_chr <- function(x) x %>%
    dplyr::mutate(
      dplyr::across(where(is.numeric), ~round(., 2)), 
      dplyr::across(dplyr::everything(), as.character),
      coupleID = as.character(coupleID)
      )

  p1c <- to_chr(p1)
  p2c <- to_chr(p2)

  # 1-row "..." tibble with same columns (all character)
  colset <- names(dfc0)
  ellipsis_row <- tibble::as_tibble(setNames(rep(list("..."), length(colset)), colset))

  dplyr::bind_rows(p1c, ellipsis_row, p2c)
}


```


```{r echo=FALSE}

print_df(print_couple_preview(df_long_apim[, c(1,2,3,5,6,7,9,10)], couple_id = "31"))  

```


## Distinguishable Dyads - L-APIM - Centering 

With repeated measures we need to center variables in order to not conflate levels of analysis:

* Between-Person: The person-mean in relation to the grand mean
* Within-Person: Daily fluctuations of an individual from their person-mean

While it may seem like we have 3-levels (couple/person/day), by including the means of both partners and their correlations in the model, all information about the couple-level (level 3) is included. This will become clear when comparing the exchangeable APIM to the DIM. We thus use a 2-level model with the dyad as the level of analysis. 

## Distinguishable Dyads - L-APIM - Centering 

```{r}
df_long_apim <- bmlm::isolate(
  df_long_apim, 
  by = 'userID', # NOT coupleID
  value = c('provided_support_actor', 'provided_support_partner'),
  which = 'both' 
) %>%
  rename(
    provided_support_actor_cwp = provided_support_actor_cw,
    provided_support_partner_cwp = provided_support_partner_cw,
    provided_support_actor_cbp = provided_support_actor_cb,
    provided_support_partner_cbp = provided_support_partner_cb,
  )
```


## Distinguishable Dyads - L-APIM - Model 



```{r}

formula <- bf(
  daily_closeness ~ 
    
    # Intercepts
    0 + is_male + is_female +
    
    # Time Slopes
    is_male:diaryday +
    is_female:diaryday +
    
    # Between-Person APIM
    is_male:provided_support_actor_cbp + 
    is_male:provided_support_partner_cbp +
    
    is_female:provided_support_actor_cbp + 
    is_female:provided_support_partner_cbp +
  
    # Within-Person APIM
    is_male:provided_support_actor_cwp + 
    is_male:provided_support_partner_cwp +
    
    is_female:provided_support_actor_cwp + 
    is_female:provided_support_partner_cwp +
    
    # Accounting for non-independence between partners' means and trajectories 
    # and effect sensitivities via random effects:
    (0 + is_male + is_female +  # Random Intercepts and their correlations
       
       is_male:diaryday + is_female:diaryday +
       
       is_male:provided_support_actor_cwp + 
       is_male:provided_support_partner_cwp +
       is_female:provided_support_actor_cwp + 
       is_female:provided_support_partner_cwp | coupleID ) + 
    
    
    # Accounting for daily non-independence
    
    # Option 1: model correlated residuals on the day with a 
    # compound symmetry structure:
    # cosy(time = diaryday, gr = coupleID),
    
    # Option 2: model daily coupling / common shocks with a random effect:
    (1 | coupleID:diaryday) +
    
    
    # Modelling Residuals as auto correlated within each person (order 1)
    ar(time = diaryday, gr = coupleID:userID, p = 1),
    
  sigma ~ 0 + is_male + is_female   # heteroscedastic residuals
)

priors <- c(
  prior(normal(0, 5), class = "b"),
  prior(student_t(3, 0, 1.5), class = "sd"),
  prior(normal(0.5, 0.3), class = "ar"),
  prior(student_t(3, 0, 1.5), class ="b", dpar = "sigma")
)


model_dist_apim_long <- brm(
  formula = formula, 
  data = df_long_apim,
  family = gaussian(link = identity),
  prior = priors,
  chains = 4,
  cores = 4,
  iter = 2000,
  warmup = 1000, 
  seed = 123,
  file = file.path('brms_cache', 'example1_dist_apim_long') # Cache the model
)

```


## Results

```{r echo=FALSE}

summary_apim <- summarize_brms(
    model_dist_apim_long, 
    stats_to_report = c('CI', 'Rhat', 'ESS')
    )

print_df(
  summary_apim, 
  rows_to_pack = list(
    'Fixed Effects' = c(1,12),
    'Random Effects' = c(13,49),
    'Residual Structure' = c(50,52)
    )
  )

```


# Exchangeable Dyads


## Exchangeable Dyads - Cross-Sectional APIM

```{r, echo=FALSE, fig.width=8, fig.align='center', include = FALSE}

DiagrammeR::grViz(glue("
  digraph APIM {{
    graph [
      size='11,11!'
      layout=dot 
      rankdir='LR' 
      label='APIM' 
      labelloc=t
    ]
    
    node [
      shape=box 
      fixedsize=true 
      width=1
      fontsize = 10
    ]
    pre1 [label='Communication \n A']
    out1 [label='Satisfaction \n A']
    pre2 [label='Communication \n B']
    out2 [label='Satisfaction \n B']
    
    edge [
      minlen=2.5
      labelfloat=true 
      fontsize=12
    ]
    pre1 -> out1 [label='a']
    pre2 -> out1 [taillabel='p' labeldistance=4 labelangle=-15 constraint=false]
    pre1 -> out2 [taillabel='p' labeldistance=4 labelangle=15 constraint=false]
    pre2 -> out2 [label='a']
  }}
"))


```

![Exchangeable APIM](APIM_ind_1.png)


## Exchangeable Dyads - Cross-Sectional APIM

![Exchangeable APIM](APIM_ind_3.png)


```{r, echo=FALSE, fig.width=7, fig.align='center', include = FALSE}

DiagrammeR::grViz(glue("
  digraph APIM {{
    graph [
      size='11,11!'
      layout=dot 
      rankdir='LR' 
      label='APIM' 
      labelloc=t
    ]
    
    node [
      shape=box 
      fixedsize=true 
      width=1
      fontsize = 10
    ]
    pre1 [label='Communication \n Self']
    out1 [label='Satisfaction \n Self']
    pre2 [label='Communication \n Partner']

    edge [
      minlen=2.5
      labelfloat=true 
      fontsize=12
    ]
    pre1 -> out1 [label='a']
    pre2 -> out1 [taillabel='p' labeldistance=3.8 labelangle=-8 constraint=false]
  }}
"))


```

--- 

## Exchangeable Dyads - Main Assumptions

Partners are exchangeable, i.e., not *systematically* different.

* Equal actor effects 
* Equal partner effects
* Equal means 
* Equal residual variances

But they should still be allowed to vary within each couple, while being correlated.

## Exchangeable Dyads - Cross-Sectional APIM: Data

Same cross-sectional data in the same 4-field actor-partner format as before. 
```{r}

print_df(head(df_apim))

```



## Exchangeable Dyads - Cross-Sectional APIM: Model


```{r }
#| code-line-numbers: "1-14|16-34"

formula <- bf(
  satisfaction ~ 1 + 
    communication_actor_gmc + communication_partner_gmc + 
    
    # Option 1: A single couple level random intercept. Too restrictive.
    # Would impose perfect correlation between partners in each couple
    # (1 | coupleID)
    
    cosy(gr = coupleID)
  
  # Note: no need to model separate sigmas for each partner.
  # Homogenous residual variance is estimated: 
  # Implied: sigma = ~ 1
)

priors <- c(
  prior(normal(2, 10), class = "Intercept"),
  prior(normal(0, 5), class = "b"),
  prior(student_t(3, 0, 1.5), class = "sigma"),
  prior(beta(1, 3), class = "cosy")
)

model_ind_apim <- brm(
  formula = formula, 
  data = df_apim,
  family = gaussian(link = identity),
  prior = priors,
  chains = 4,
  cores = 4,
  iter = 2000,
  warmup = 1000, 
  seed = 123,
  file = file.path('brms_cache', 'example1_ind_apim') # Cache the model
)

```


## Exchangeable Dyads - Cross-Sectional APIM: Results

```{r, echo=FALSE}

summary_apim <- summarize_brms(
    model_ind_apim, 
    stats_to_report = c('CI', 'Rhat', 'ESS')
    )

print_df(
  summary_apim, 
  rows_to_pack = list(
    'Fixed Effects' = c(1,3),
    'Residual Structure' = c(4,5)
    )
  )

```


## Exchangeable Dyads - Cross-Sectional APIM: Test for Distinguishability

Leave-one-out (loo) cross validation for model comparison (even if not nested).

```{r eval=FALSE}
a <- loo_compare(
  loo(model_ind_apim), 
  loo(model_dist_apim)
)
print(a)
```

| Model             | elpd_diff | se_diff | 
|-------------------|-----------|---------|
| model_dist_apim   | 0.0       | 0.0     | 
| model_ind_apim    | -98.7     | 13.0    | 


```{r eval = FALSE}
report::report(a)
```

<p style="font-size:80%; line-height:1.35">
The difference in predictive accuracy, as indexed by Expected Log Predictive 
Density (ELPD-LOO), suggests that 'model_dist_apim' is the best model (ELPD = -1965.61), 
followed by 'model_ind_apim' (diff-ELPD = -98.72 ± 13.00, p &lt; .001).<br>
See: <a href="https://easystats.github.io/report/reference/report.compare.loo.html">documentation of "report"</a>
</p>

## Exchangeable Dyads - Cross-Sectional DIM

```{r, echo=FALSE}

DiagrammeR::grViz(glue("
  digraph DIM {{
    graph [
      size='11,11!'
      layout=dot
      rankdir='LR'
      label='Dyad–Individual Model (DIM)'
      labelloc=t
    ]

    node [
      shape=box
      fixedsize=true
      width=1.4
      fontsize=10
    ]
    pre1 [label='Communication\\nBetween-couple (cbc)']
    out1 [label='Satisfaction\\n(Self)']
    pre2 [label='Communication\\nWithin-couple (cwc)']

    edge [
      minlen=2.5
      labelfloat=true
      fontsize=12
    ]
    pre1 -> out1 [label='between']
    pre2 -> out1 [taillabel='within' labeldistance=4 labelangle=-15 constraint=false]
  }}
"))


```

---

## Exchangeable Dyads - Cross-Sectional DIM: Data

Starting from scratch (no 4-field data needed)

```{r echo = FALSE}

df_apim2 <- df_apim[, c('userID', 'coupleID', 'communication', 'satisfaction')]

print_df(head(df_apim2))

```

## Exchangeable Dyads - Cross-Sectional DIM: Centering

Decompose `communication` variance into:

* **Between-couple** (cbc): Couple-mean communication skills in relation to other couples
* **Within-couple** (cwc): Individuals communication skills in relation to their couple-mean

Same assumption about exchangeability as in the APIM

## Exchangeable Dyads - Cross-Sectional DIM: Centering


```{r}
df_dim <- df_apim2 %>%
  group_by(coupleID) %>%
  mutate(
    communication_cm = mean(communication, na.rm = TRUE),
    communication_cwc= communication - communication_cm
  ) %>%
  ungroup() %>%
  mutate(
    communication_cbc= communication_cm - mean(communication_cm, na.rm = TRUE)
  ) %>% 
  select(c('userID', 'coupleID', 'satisfaction', 'communication_cwc', 'communication_cbc'))

print_df(head(df_dim))
```


## Exchangeable Dyads - Cross-Sectional DIM: Model

```{r}
#| code-line-numbers: "1-5|7-11|12-24"

formula <- bf(
  satisfaction ~ 1 + 
    communication_cbc+ communication_cwc + 
    cosy(gr = coupleID) 
)

priors <- c(
  prior(normal(2, 10), class = "Intercept"),
  prior(normal(0, 5), class = "b"),
  prior(student_t(3, 0, 1.5), class = "sigma"),
  prior(beta(1, 3), class = "cosy")
)

model_ind_dim <- brm(
  formula = formula, 
  data = df_dim,
  family = gaussian(link = identity),
  prior = priors,
  chains = 4,
  cores = 4,
  iter = 2000,
  warmup = 1000, 
  seed = 123,
  file = file.path('brms_cache', 'example1_ind_dim') # Cache the model
)

```


## Exchangeable Dyads - Cross-Sectional DIM: Results

```{r, echo=FALSE}

summary_dim <- summarize_brms(
    model_ind_dim, 
    stats_to_report = c('CI', 'Rhat', 'ESS')
    )

print_df(
  summary_dim, 
  rows_to_pack = list(
    'Fixed Effects' = c(1,3),
    'Residual Structure' = c(4,5)
    )
  )
```


## Equivalence APIM and DIM

![APIM (left) vs. DIM (right)](croppedResults1.png)

$$b_{actor\_gmc} + b_{partner\_gmc} = b_{cbc}$$
$$b_{actor\_gmc} - b_{partner\_gmc} = b_{cwc}$$ 
[@Bolger2025Unified]
## Equivalence APIM and DIM


```{=html}
<img src="croppedResults1_shallow.png" alt="Results"
     style="display:block; margin:1.5rem auto; max-width:800px; width:100%; height:auto;">

<section data-background-color="#ffffff">
  <p style="margin-top:0;font-size:1.2rem;max-width:1100px;">
    Top sliders: grand-mean-centered <em>Communication</em> for <strong>Actor</strong> and <strong>Partner</strong> (APIM).<br>
    Bottom sliders: reparameterized communication — <strong>Centered Between-Couple</strong> (<code>x<sub>cbc</sub></code>) and <strong>Centered Within-Couple</strong> (<code>x<sub>cwc</sub></code>) (DIM).<br>
  </p>

  <style>
    .slider-grid{
      display:grid;
      grid-template-columns:250px 1fr 80px auto;
      gap:14px;
      align-items:center;
      font-size:1.2rem;
      margin-bottom:1.2rem;
      width:100%;
    }
    .slider-grid>label{grid-column:1;font-weight:600}
    .slider-grid>input[type="range"]{grid-column:2;width:100%;accent-color:steelblue;height:10px;cursor:pointer}
    .slider-grid>input[data-group="lower"]{accent-color:coral}
    .slider-grid>output{grid-column:3;font-variant-numeric:tabular-nums;text-align:right;width:3.8ch;font-size:1.15rem}
    .reset-cell{grid-column:4;grid-row:1/-1;align-self:center;justify-self:start}
    #reset-btn{background:#4B5563;color:#FAFAFA;border:none;padding:.6rem 1.2rem;border-radius:8px;font-size:1.05rem;cursor:pointer;transition:background .2s}
    #reset-btn:hover{background:#1F2937}

    .equations{margin-top:1.1rem}
    .math{
      font-family:'STIX Two Text','Times New Roman',serif;
      font-size:1.30rem;
      line-height:1.6;
      font-variant-numeric:lining-nums tabular-nums;
      letter-spacing:.05px;
    }
    .eq-table{
      display:grid;
      grid-template-columns:
        1.5ch auto 1.4ch minmax(7.8ch,max-content) 1.4ch minmax(19ch,max-content)
        1.4ch minmax(19ch,max-content) 1.4ch minmax(8.6ch,max-content);
      column-gap:.7rem; row-gap:.45rem; align-items:baseline; justify-content:start; width:100%;
    }
    .cell.label{font-weight:750;color:#334155;font-size:1.32rem}
    .cell.op{opacity:.9;text-align:center}

    .num{display:inline-flex;align-items:baseline}
    .sign{display:inline-block;width:1.1ch;text-align:right;padding-right:.18ch}
    .minus{visibility:visible}.phantom{visibility:hidden}
    .digits{display:inline-block;min-width:5.6ch;text-align:left}
    .times{padding:0 .24rem;font-weight:700;font-size:1.10em}

    .stack{display:inline-flex;flex-direction:column;align-items:center;gap:.08rem}
    .vlabel{font-size:.82rem;line-height:1;letter-spacing:.2px}

    .apx .digits,.apx .sign{color:steelblue}
    .dimx .digits,.dimx .sign{color:coral}
    .apx .vlabel{color:steelblue;font-weight:650}
    .dimx .vlabel{color:coral;font-weight:650}
    .coefwrap .vlabel{color:#6B7280;font-weight:500}
    .result .digits,.result .sign{color:#0f172a;font-weight:800}
  </style>

  <div class="slider-grid">
    <!-- Compact symbolic labels -->
    <label style="color:steelblue;">x<sub>actor_gmc</sub></label>
    <input id="slider-actor" type="range" min="-5" max="5" step="0.1"
      value="0"
      data-group="upper">
    <output id="out-actor">0.00</output>

    <label style="color:steelblue;">x<sub>partner_gmc</sub></label>
    <input id="slider-partner" type="range" min="-5" max="5" step="0.1"
      value="0"
      data-group="upper">
    <output id="out-partner">0.00</output>

    <label style="color:#E26A5C;">x<sub>cbc</sub></label>
    <input id="slider-mean" type="range" min="-5" max="5" step="0.1" value="0" data-group="lower">
    <output id="out-mean">0.00</output>

    <label style="color:#E26A5C;">x<sub>cwc</sub></label>
    <input id="slider-within" type="range" min="-5" max="5" step="0.1" value="0" data-group="lower">
    <output id="out-within">0.00</output>

    <div class="reset-cell"><button id="reset-btn">Reset to 0</button></div>
  </div>

  <!-- Model coefficients -->
  <div id="model-coefs"
       data-apim-b0="`r round(fixef(model_ind_apim)['Intercept','Estimate'], 2)`"
       data-apim-ba="`r round(fixef(model_ind_apim)['communication_actor_gmc','Estimate'], 2)`"
       data-apim-bp="`r round(fixef(model_ind_apim)['communication_partner_gmc','Estimate'], 2)`"
       data-dim-b0 ="`r round(fixef(model_ind_dim)['Intercept','Estimate'], 2)`"
       data-dim-cb ="`r round(fixef(model_ind_dim)['communication_cbc','Estimate'], 2)`"
       data-dim-cw ="`r round(fixef(model_ind_dim)['communication_cwc','Estimate'], 2)`"></div>

  <div class="equations">
    <div id="eq-table" class="eq-table math"></div>
  </div>

  <script>
(function(){
  const MIN=-5, MAX=5;
  const clamp=(x,lo,hi)=>Math.min(hi,Math.max(lo,x));
  const r1 = x => Math.round(x*10)/10;
  const r2 = x => { const y=Math.round(Number(x)*100)/100; return Math.abs(y)<1e-12?0:y; };

  // Elements
  const actor   = document.getElementById('slider-actor');   // x_actor_gmc
  const partner = document.getElementById('slider-partner'); // x_partner_gmc
  const mean    = document.getElementById('slider-mean');    // x_cbc
  const within  = document.getElementById('slider-within');  // x_cwc

  const outA = document.getElementById('out-actor');
  const outP = document.getElementById('out-partner');
  const outM = document.getElementById('out-mean');
  const outW = document.getElementById('out-within');

  const TIMES='×', MINUS='−';
  const coefEl=document.getElementById('model-coefs').dataset;
  const C = {
    apim:{ b0:+coefEl.apimB0, b_actor_gmc:+coefEl.apimBa, b_partner_gmc:+coefEl.apimBp },
    dim: { b0:+coefEl.dimB0,  b_cbc:+coefEl.dimCb,        b_cwc:+coefEl.dimCw }
  };

  const table=document.getElementById('eq-table');

  function SignedNumHTML(v, extra=''){
    const y=r2(v), neg=y<0, abs=Math.abs(y).toFixed(2);
    return `<span class="num ${extra}"><span class="sign ${neg?'minus':'phantom'}">${MINUS}</span><span class="digits">${abs}</span></span>`;
  }
  function VarNumber(label, value, colorClass){
    return `<span class="stack ${colorClass}"><span>${SignedNumHTML(value)}</span><span class="vlabel">${label}</span></span>`;
  }
  function CoefNumber(label, value){
    return `<span class="stack coefwrap"><span>${SignedNumHTML(value,'coef')}</span><span class="vlabel">${label}</span></span>`;
  }
  function row({modelLabel,b0Label,b0,b1Label,b1,x1Label,x1Val,x1Class,b2Label,b2,x2Label,x2Val,x2Class,yVal}){
    return `
      <div></div>
      <div class="cell label">${modelLabel}:&nbsp;Y</div>
      <div class="cell op">=</div>
      <div class="cell">${CoefNumber(b0Label,b0)}</div>
      <div class="cell op">+</div>
      <div class="cell">${CoefNumber(b1Label,b1)}<span class="times">${TIMES}</span>${VarNumber(x1Label,x1Val,x1Class)}</div>
      <div class="cell op">+</div>
      <div class="cell">${CoefNumber(b2Label,b2)}<span class="times">${TIMES}</span>${VarNumber(x2Label,x2Val,x2Class)}</div>
      <div class="cell op">=</div>
      <div class="cell result">${SignedNumHTML(yVal,'result')}</div>`;
  }

  function render(){
    const A=+actor.value, P=+partner.value, M=+mean.value, W=+within.value;
    const yAPIM = C.apim.b0 + C.apim.b_actor_gmc*A + C.apim.b_partner_gmc*P;
    const yDIM  = C.dim.b0  + C.dim.b_cbc*M        + C.dim.b_cwc*W;
    table.innerHTML =
      row({modelLabel:'APIM',
        b0Label:'b<sub>0</sub>', b0:C.apim.b0,
        b1Label:'b<sub>actor_gmc</sub>', b1:C.apim.b_actor_gmc,
        x1Label:'x<sub>actor_gmc</sub>', x1Val:A, x1Class:'apx',
        b2Label:'b<sub>partner_gmc</sub>', b2:C.apim.b_partner_gmc,
        x2Label:'x<sub>partner_gmc</sub>', x2Val:P, x2Class:'apx',
        yVal:yAPIM
      }) +
      row({modelLabel:'DIM',
        b0Label:'b<sub>0</sub>', b0:C.dim.b0,
        b1Label:'b<sub>cbc</sub>', b1:C.dim.b_cbc,
        x1Label:'x<sub>cbc</sub>', x1Val:M, x1Class:'dimx',
        b2Label:'b<sub>cwc</sub>', b2:C.dim.b_cwc,
        x2Label:'x<sub>cwc</sub>', x2Val:W, x2Class:'dimx',
        yVal:yDIM
      });
  }

  function updateOutputs(){
    outA.value=(+actor.value).toFixed(2);
    outP.value=(+partner.value).toFixed(2);
    outM.value=(+mean.value).toFixed(2);
    outW.value=(+within.value).toFixed(2);
  }

  /* =======================
     Feasible-interval helpers
     ======================= */
  // For moving A with P fixed:
  function feasibleA(p){
    // m=(a+p)/2 in [MIN,MAX]  -> a in [2*MIN - p, 2*MAX - p]
    // w=(a-p)/2 in [MIN,MAX]  -> a in [2*MIN + p, 2*MAX + p]
    const lo = Math.max(MIN, 2*MIN - p, 2*MIN + p);
    const hi = Math.min(MAX, 2*MAX - p, 2*MAX + p);
    return [lo, hi];
  }
  // For moving P with A fixed:
  function feasibleP(a){
    const lo = Math.max(MIN, 2*MIN - a, -2*MAX + a); // from w=(a-p)/2 -> p in [a-2*MAX, a-2*MIN]
    const hi = Math.min(MAX, 2*MAX - a, -2*MIN + a);
    // cleaner symmetrical form:
    return [Math.max(MIN, 2*MIN - a, a - 2*MAX),
            Math.min(MAX, 2*MAX - a, a - 2*MIN)];
  }
  // For moving M with W fixed:
  function feasibleM(w){
    // a=m+w ∈ [MIN,MAX] -> m ∈ [MIN - w, MAX - w]
    // p=m-w ∈ [MIN,MAX] -> m ∈ [MIN + w, MAX + w]
    const lo = Math.max(MIN, MIN - w, MIN + w);
    const hi = Math.min(MAX, MAX - w, MAX + w);
    return [lo, hi];
  }
  // For moving W with M fixed:
  function feasibleW(m){
    // a=m+w ∈ [MIN,MAX] -> w ∈ [MIN - m, MAX - m]
    // p=m-w ∈ [MIN,MAX] -> w ∈ [m - MAX, m - MIN]
    const lo = Math.max(MIN, MIN - m, m - MAX);
    const hi = Math.min(MAX, MAX - m, m - MIN);
    return [lo, hi];
  }

  /* =======================
     Move handlers (clamp the moved slider FIRST)
     ======================= */
  function moveActor(){
    const p = r1(+partner.value);
    const [lo,hi] = feasibleA(p);
    const a = r1(clamp(+actor.value, lo, hi)); // hard-stop the thumb
    actor.value = a;
    const m = r1((a + p)/2), w = r1((a - p)/2);
    mean.value = m; within.value = w;
    updateOutputs(); render();
  }
  function movePartner(){
    const a = r1(+actor.value);
    const [lo,hi] = feasibleP(a);
    const p = r1(clamp(+partner.value, lo, hi));
    partner.value = p;
    const m = r1((a + p)/2), w = r1((a - p)/2);
    mean.value = m; within.value = w;
    updateOutputs(); render();
  }
  function moveMean(){
    const w = r1(+within.value);
    const [lo,hi] = feasibleM(w);
    const m = r1(clamp(+mean.value, lo, hi));
    mean.value = m;
    const a = r1(m + w), p = r1(m - w);
    actor.value = a; partner.value = p;
    updateOutputs(); render();
  }
  function moveWithin(){
    const m = r1(+mean.value);
    const [lo,hi] = feasibleW(m);
    const w = r1(clamp(+within.value, lo, hi));
    within.value = w;
    const a = r1(m + w), p = r1(m - w);
    actor.value = a; partner.value = p;
    updateOutputs(); render();
  }

  // Listeners
  actor  .addEventListener('input', moveActor);
  partner.addEventListener('input', movePartner);
  mean   .addEventListener('input', moveMean);
  within .addEventListener('input', moveWithin);

  document.getElementById('reset-btn').addEventListener('click', ()=>{
    actor.value=partner.value=mean.value=within.value=0;
    updateOutputs(); render();
  });

  updateOutputs(); render();
})();
</script>


</section>



```


## Equivalence APIM and DIM

* If the couple mean goes up by 1 and the within-couple deviation from the couple 
mean stays fixed, this means that both partners' predictors must go up by 1 unit. 
Thus, the effects are linear combinations: 

$$b_{cbc} = b_{actor\_gmc} + b_{partner\_gmc}$$

* Similarly, if a person's deviation from their couple mean is one unit higher and
the couple mean stays fixed, this means their partners' deviation must be one unit lower. 
Thus, the effects are a linear combination: 

$$b_{cwc} = b_{actor\_gmc} - b_{partner\_gmc}$$

## Equivalence APIM and DIM

* Conversely, to obtain the actor and partner effects given the DIM estimates: 

$$b_{actor\_gmc} = \frac{b_{cbc} + b_{cwc}}{2}$$

$$b_{partner\_gmc} = \frac{b_{cbc} - b_{cwc}}{2}$$

## Equivalence APIM and DIM

Example: using APIM coefficients to obtain DIM coefficients and computing *Credible Intervals* of DIM coefficients. 

```{r}
a <- hypothesis(
  model_ind_apim, 
  "communication_actor_gmc + communication_partner_gmc = 0"
)

a$hypothesis[,c(2,3,4,5)]
```

![APIM (left) vs. DIM (right)](croppedResults1.png)



## Equivalence APIM and DIM: Takeaway

* **APIM** and **DIM** are reparametrizations of the same model
* **APIM**: intuitive actor/partner framing
* **DIM**: clean separation of between vs within components
* Estimating one model allows for directly obtaining estimates of the other
* Same random-effects structure at dyad level and same assumptions

### Side Note:

In the **distinguishable** case, the **Dyadic Score Model (DSM)** [e.g., @stadlerHowCompanionshipRelated2023] is equivalent to the APIM! [@Bolger2025Unified; @iidaModelsInterdependentIndividuals2018]


## Exchangeable Dyads - Longuitudinal APIM/DIM: Data

```{r}
df_long_apim2 <- df_long_apim %>%
  select('coupleID', 'userID', 'diaryday', 'daily_closeness', 'provided_support_actor_cwp', 'provided_support_partner_cwp', 'provided_support_actor_cbp', , 'provided_support_partner_cbp')

print_df(print_couple_preview(df_long_apim2, couple_id = "31"))  

```


## Exchangeable Dyads - Longuitudinal DIM/APIM

* We need an APIM or DIM on both the between person level and the within-person level.
* Due to equivalence, we could have a DIM on one level and an APIM on the other. 

If we want a within-person DIM:

```{r}
df_long_dim <- df_long_apim2 %>%
  mutate(
    
    # Between Person Level DIM (centering between couples and within couple between person)
    provided_support_cbc = (provided_support_actor_cbp + provided_support_partner_cbp) / 2,
    provided_support_cwcbp = (provided_support_actor_cbp - provided_support_partner_cbp) / 2,
    
    # Within Person Level DIM (couple mean and deviation on each day)
    provided_support_cwp_mean = (provided_support_actor_cwp + provided_support_partner_cwp) / 2,
    provided_support_cwp_halfdiff = (provided_support_actor_cwp - provided_support_partner_cwp) / 2
  ) 


```

## Exchangeable Dyads - Longuitudinal DIM/APIM: Preparing the sum and difference approach

We need to randomly assign -1 and +1 for each Partner within each couple. 
This will be needed for contrast coding the intercept. 

For example:

```{r eval = FALSE}

df_long_dim <- df_long_dim %>%
  group_by(coupleID) %>%
  mutate(
    base = ifelse(userID == min(userID), 1, -1),
    flip = 1 - 2 * rbinom(1, 1, 0.5),   # yields +1 or -1 once per couple
    Idiff = base * flip
  ) %>%
  ungroup() %>%
  relocate(Idiff, .after = userID) %>%
  select(-base, -flip)


print_df(print_couple_preview(df_long_dim, couple_id = "31"))  

```


## Exchangeable Dyads - Longuitudinal DIM/APIM: Preparing the Sum and Difference Approach

```{r echo=FALSE}

df_long_dim <- df_long_dim %>%
  group_by(coupleID) %>%
  mutate(
    base = ifelse(userID == min(userID), 1, -1),
    flip = 1 - 2 * rbinom(1, 1, 0.5),   # yields +1 or -1 once per couple
    Idiff = base * flip
  ) %>%
  ungroup() %>%
  relocate(Idiff, .after = userID) %>%
  select(-base, -flip)


print_df(print_couple_preview(df_long_dim, couple_id = "31"))  

```

## Exchangeable Dyads - Longuitudinal APIM/DIM: Model

```{r }

formula <- bf(
  daily_closeness ~ 1 + 
    
    diaryday +
  
    # Within-person APIM
    provided_support_actor_cwp + 
    provided_support_partner_cwp +
    # Equivalent to within-person DIM:
    # provided_support_cwp_mean + 
    # provided_support_cwp_halfdiff +
  
    # Between-person APIM
    provided_support_actor_cbp +
    provided_support_partner_cbp +
    # Equivalent to between-person DIM
    # provided_support_cwcbp+
    # provided_support_cbc +
    
    # Dyad-Level intercept and slopes for time-varying predictors
    (1 + diaryday + provided_support_actor_cwp + provided_support_partner_cwp | coupleID) +
    # Both partners' deviations from these dyad-level means and slopes
    (0 + Idiff + 
         I(Idiff * diaryday) + 
         I(Idiff * provided_support_actor_cwp) + 
         I(Idiff * provided_support_partner_cwp) | coupleID) +
    
    # Accounting for same-day shocks/coupling
    (1 | coupleID:diaryday) +
    # alternatively and equivalently if no autocorrelation needed:
    # cosy(time = diaryday, gr = coupleID) 
    
    # Autocorrelated residuals
    ar(time = diaryday, gr = coupleID:userID, p = 1)
  
  # Again, no need to model heterogeneous residual variances (sigma)
  # Implied: sigma = ~ 1
)

priors <- c(
  prior(normal(2, 10), class = "Intercept"),
  prior(normal(0, 5), class = "b"),
  prior(student_t(3, 0, 1.5), class = "sd"),
  prior(lkj(2), class = "cor"), # correlation prior for random effect matrix
  prior(normal(0.5, 0.3), class = "ar"),
  prior(student_t(3, 0, 1.5), class = "sigma")
)

model_apim_ind_long <- brm(
  formula = formula, 
  data = df_long_dim,
  family = gaussian(link = identity),
  prior = priors,
  chains = 4,
  cores = 4,
  iter = 2000,
  warmup = 1000, 
  seed = 123,
  file = file.path('brms_cache', 'model_apim_ind_long_both')
)


```

```{r echo=FALSE, results='hide', message=FALSE}

# DIM Version
formula <- bf(
  daily_closeness ~ 1 + 
    
    diaryday +
    
    provided_support_cwp_mean + 
    provided_support_cwp_halfdiff +
  
    provided_support_cwcbp+
    provided_support_cbc +
    
    (1 + diaryday + provided_support_actor_cwp + provided_support_partner_cwp | coupleID) +
    (0 + Idiff + 
         I(Idiff * diaryday) + 
         I(Idiff * provided_support_actor_cwp) + 
         I(Idiff * provided_support_partner_cwp) | coupleID) +
    
    (1 | coupleID:diaryday) +

    ar(time = diaryday, gr = coupleID:userID, p = 1)
)

priors <- c(
  prior(normal(2, 10), class = "Intercept"),
  prior(normal(0, 5), class = "b"),
  prior(student_t(3, 0, 1.5), class = "sd"),
  prior(lkj(2), class = "cor"), # correlation prior for random effect matrix
  prior(normal(0.5, 0.3), class = "ar"),
  prior(student_t(3, 0, 1.5), class = "sigma")
)

model_dim_ind_long <- brm(
  formula = formula, 
  data = df_long_dim,
  family = gaussian(link = identity),
  prior = priors,
  chains = 4,
  cores = 4,
  iter = 2000,
  warmup = 1000, 
  seed = 123,
  file = file.path('brms_cache', 'model_apim_ind_long_both2')
)


```


## Exchangeable Dyads - Longuitudinal APIM/DIM: Explanation Idiff

For appropriate random effects, we can use the Sum and Difference approach [@delrosarioPracticalGuideSpecifying2025; @kenny_ackerman_2023]: 

* Randomly give one partner a constant of -1 and the other a constant of 1
* The couple level intercept represents the mean (or sum) of both partners intercepts `(1 | coupleID)`
* A column of 1s and -1s represent deviations (difference) of each partner from the couple intercept with each partner contributing equally in one direction (+1 and -1)

Exchangeability is retained, if partners are flipped, the result is the same.

(@delrosarioPracticalGuideSpecifying2025 provided practical guidance on how to reduce the random effects structure in case of non-convergence.)

## Exchangeable Dyads - Longuitudinal APIM/DIM: Results

Comparing APIM (left) and DIM (right) output

![APIM (left) vs. DIM (right) APIM](croppedResults2.png)

Equivalence holds on both levels

## Exchangeable Dyads - Longuitudinal APIM/DIM: Results

APIM Results in Detail:

```{r echo=FALSE}
summary_apim <- summarize_brms(
    model_apim_ind_long, 
    stats_to_report = c('CI', 'Rhat', 'ESS')
    )

print_df(
  summary_apim, 
  rows_to_pack = list(
    'Fixed Effects' = c(1,6),
    'Random Effects' = c(7, 27),
    'Residual Structure' = c(28, 29)
    )
  )

```



## Extract Full APIM Random Effects Variance-Covariance Matrix

We can rotate the random effects structure back to obtain the full APIM Random effects variance-covariance matrix. 
Just as we would in a SEM model with equality constraints!

```{r}
# Custom function 
rotate_apim_covariance <- function(
    fit,
    gr = "coupleID",
    Idiff = "Idiff"
) {
  random_effects <- fit$ranef
  random_effects <- random_effects[random_effects$group == gr,]

  SUM <- random_effects$coef[!grepl(Idiff, random_effects$coef)]
  DIFF <- random_effects$coef[grepl(Idiff, random_effects$coef)]
  
  varcor <- VarCorr(fit)[[gr]]
  
  within_person_covariance_matrix <- varcor$cov[SUM,'Estimate',SUM] + varcor$cov[DIFF,'Estimate',DIFF]
  cross_person_covariance_matrix <- varcor$cov[SUM,'Estimate',SUM] - varcor$cov[DIFF,'Estimate',DIFF]
  
  p <- nrow(within_person_covariance_matrix)
  
  Full <- rbind(
    cbind(within_person_covariance_matrix,  cross_person_covariance_matrix),
    cbind(cross_person_covariance_matrix, within_person_covariance_matrix)
  )
  
  # nice labels
  base <- SUM
  rn <- c(paste0("PartnerA_", base), paste0("PartnerB_", base))
  colnames(Full) <- rn
  rownames(Full) <- rn
  
  return(list(within_person_covariance_matrix=within_person_covariance_matrix, cross_person_covariance_matrix=cross_person_covariance_matrix, full_covariance_matrix=Full))
}

a <- rotate_apim_covariance(model_apim_ind_long)

```

## Extract Full APIM Random Effects Variance-Covariance Matrix: Within-Person Matrix

```{r}
print_df(a$within_person_covariance_matrix)
```


## Extract Full APIM Random Effects Variance-Covariance Matrix: Cross-Person Matrix

```{r}
print_df(a$cross_person_covariance_matrix)
```


## Extract Full APIM Random Effects Variance-Covariance Matrix: Full Matrix

```{r}
print_df(a$full_covariance_matrix)
```


## References






